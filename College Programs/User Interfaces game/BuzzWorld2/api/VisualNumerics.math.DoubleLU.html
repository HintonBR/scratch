<!--NewPage-->
<html>
<head>
<!-- Generated by javadoc on Thu Jun 26 20:45:00 tra 1997 -->
<a name="_top_"></a>
<title>
  Class VisualNumerics.math.DoubleLU
</title>
</head>
<body>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-VisualNumerics.math.html">This Package</a>  <a href="VisualNumerics.math.DoubleCholesky.html#_top_">Previous</a>  <a href="VisualNumerics.math.DoubleMatrix.html#_top_">Next</a>  <a href="AllNames.html">Index</a></pre>
<hr>
<h1>
  Class VisualNumerics.math.DoubleLU
</h1>
<pre>
<a href="java.lang.Object.html#_top_">java.lang.Object</a>
   |
   +----VisualNumerics.math.DoubleLU
</pre>
<hr>
<dl>
  <dt> public class <b>DoubleLU</b>
  <dt> extends <a href="java.lang.Object.html#_top_">Object</a>
</dl>
LU factorization of a matrix of type double.
<hr>
<a name="index"></a>
<h2>
  <img src="images/constructor-index.gif" width=275 height=38 alt="Constructor Index">
</h2>
<dl>
  <dt> <img src="images/yellow-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#DoubleLU(double[][])"><b>DoubleLU</b></a>(double[][])
  <dd> 
Create the LU factorization of a square matrix of type double.
</dl>
<h2>
  <img src="images/method-index.gif" width=207 height=38 alt="Method Index">
</h2>
<dl>
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#condition()"><b>condition</b></a>()
  <dd> 
Return an estimate of the reciprocal of the L</FONT><SUB><FONT SIZE="1">1</FONT></SUB><FONT
 SIZE="3"> condition number of the matrix used to construct
this instance.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#determinant()"><b>determinant</b></a>()
  <dd> 
Return the determinant of the matrix used to construct this instance.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#inverse()"><b>inverse</b></a>()
  <dd> 
Compute the inverse of a matrix of type double.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#ipvt()"><b>ipvt</b></a>()
  <dd> 
Return a vector containing the pivoting information from 
the LU factorization.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#solve(double[])"><b>solve</b></a>(double[])
  <dd> 
Return the solution x of the linear system Ax = b using the LU 
factorization of A.
</dl>
<a name="constructors"></a>
<h2>
  <img src="images/constructors.gif" width=231 height=38 alt="Constructors">
</h2>
<a name="DoubleLU"></a>
<a name="DoubleLU(double[][])"><img src="images/yellow-ball.gif" width=12 height=12 alt=" o "></a>
<b>DoubleLU</b>
<pre>
  public DoubleLU(double a[][]) throws <a href="java.lang.IllegalArgumentException.html#_top_">IllegalArgumentException</a>, <a href="VisualNumerics.math.MathException.html#_top_">MathException</a>
</pre>
<dl>
  <dd> Create the LU factorization of a square matrix of type double.
  <dl>
    <dt> <b>Parameters:</b>
    <dd> a - Input square matrix of type double to be factored.
    <dt> <b>Throws:</b> <a href="java.lang.IllegalArgumentException.html#_top_">IllegalArgumentException</a>
    <dd> This exception is issued when the row lengths of 
input matrix a are not equal (i.e. the matrix edges are "jagged".)
    <dt> <b>Throws:</b> <a href="VisualNumerics.math.MathException.html#_top_">MathException</a>
    <dd> This exception is issued when the input matrix a is singular.
	<DT><B>
Algorithm:
	</B><DD>
 The LU factorization is done using scaled partial pivoting. Scaled
 partial pivoting differs from partial pivoting in that the pivoting 
 strategy is the same as if each row were scaled to have the same
 infinity norm. The constructor is based on the <I>LINPACK</I> routine DGECO.
	<DT><B>
Example:
	</B><DD>
 <pre>
import VisualNumerics.math.DoubleLU;
import VisualNumerics.math.MathException;
import java.io.*;
class testDLU {
   public static void main(String args[]) {
        double   ainv[][], x[];
        double   determ;
        double   a[][] = {{ 1.0, 3.0, 3.0},
                          { 1.0, 3.0, 4.0},
                          { 1.0, 4.0, 3.0}};
        double b[] = {1.0, 4.0, -1.0};
        try {
            DoubleLU lu = new DoubleLU(a);
            determ = lu.determinant();
            x = lu.solve(b);
            ainv = lu.inverse();
            // ... print results ...
        } catch (IOException ioe) {
            System.err.println(ioe.toString());
        } catch (IllegalArgumentException e) {
            System.err.println(e.toString());
        } catch (MathException e) {
            System.err.println(e.toString());
        }
    }
}
	</pre>
  </dl>
</dl>
<a name="methods"></a>
<h2>
  <img src="images/methods.gif" width=151 height=38 alt="Methods">
</h2>
<a name="solve(double[])"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="solve"><b>solve</b></a>
<pre>
  public double[] solve(double b[])
</pre>
<dl>
  <dd> Return the solution x of the linear system Ax = b using the LU 
factorization of A.
  <dl>
    <dt> <b>Parameters:</b>
    <dd> b - Input vector of type double containing the right-hand side of the linear system.
    <dt> <b>Returns:</b>
    <dd> A vector of type double containing the solution to the linear system of
equations.
	<DT><B>
Algorithm:
	</B><DD>
	The DoubleLU constructor computes an LU factorization of a matrix with elements of type double. 
 The solution to Ax = b is found by solving the simpler systems Ly = b
 and Ux = y, where L and U are triangular matrices . The forward elimination step consists of solving the system 
 Ly = b by applying the same permutations and elimination operations to b
 that were applied to the columns of A in the factorization. The backward
 substitution step consists of solving the triangular system Ux = y for x.
	This method is based on the <I>LINPACK</I> routine DGESL.
  </dl>
</dl>
<a name="inverse()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="inverse"><b>inverse</b></a>
<pre>
  public double[][] inverse()
</pre>
<dl>
  <dd> Compute the inverse of a matrix of type double.
  <dl>
    <dt> <b>Returns:</b>
    <dd> The inverse of the matrix used to construct this object.
	<DT><B>
Algorithm:
	</B><DD>
The matrix inverse is constructed columnwise by invoking solve()
with successive columns of the identity matrix.
  </dl>
</dl>
<a name="determinant()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="determinant"><b>determinant</b></a>
<pre>
  public double determinant()
</pre>
<dl>
  <dd> Return the determinant of the matrix used to construct this instance.
  <dl>
    <dt> <b>Returns:</b>
    <dd> A double scalar containing the determinant of the  
matrix used to construct this instance.
	<DT><B> 
Algorithm:
	</B><DD>
The DoubleLU constructor executes LU factorization of the
matrix. The product of the diagonal elements of the LU 
factorization is then obtained. The determinant is this product with the sign 
adjusted based on the number of pivoting interchanges that have 
occurred in the LU factorization. This method is based on <I>LINPACK</I> routine DGEDI.
  </dl>
</dl>
<a name="condition()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="condition"><b>condition</b></a>
<pre>
  public double condition()
</pre>
<dl>
  <dd> Return an estimate of the reciprocal of the L</FONT><SUB><FONT SIZE="1">1</FONT></SUB><FONT
 SIZE="3"> condition number of the matrix used to construct
this instance.
  <dl>
    <dt> <b>Returns:</b>
    <dd> An estimate of the reciprocal of the L</FONT><SUB><FONT SIZE="1">1</FONT></SUB><FONT
 SIZE="3"> condition number of the matrix used to construct this instance.
 <DT><B>
Algorithm:
	</B><DD>
	The DoubleLU constructor computes an LU factorization of the matrix. 
 This factorization is then used by this method in determining the condition 
 number. The L</FONT><SUB><FONT SIZE="1">1</FONT></SUB><FONT
 SIZE="3"> condition number of a matrix A is defined to be the 1-norm 
 of A times the 1-norm of A inverse. Since it is expensive to compute the
 1-norm of A inverse, the condition number is only estimated. The estimation 
 algorithm is the same as the algorithm used by the <I>LINPACK</I> routine DGECO.	A condition 
 number less than approximately 2.22e-16 indicates that very small 
 changes in A can cause very large changes in the solution x of a linear
 system involving A.
  </dl>
</dl>
<a name="ipvt()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="ipvt"><b>ipvt</b></a>
<pre>
  public int[] ipvt()
</pre>
<dl>
  <dd> Return a vector containing the pivoting information from 
the LU factorization.
  <dl>
    <dt> <b>Returns:</b>
    <dd> A vector with integer elements containing the pivoting
information from the LU factorization.
  </dl>
</dl>
<hr>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-VisualNumerics.math.html">This Package</a>  <a href="VisualNumerics.math.DoubleCholesky.html#_top_">Previous</a>  <a href="VisualNumerics.math.DoubleMatrix.html#_top_">Next</a>  <a href="AllNames.html">Index</a></pre>
</body>
</html>
